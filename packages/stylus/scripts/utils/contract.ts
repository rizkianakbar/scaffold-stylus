import * as path from "path";
import * as fs from "fs";
import { ethers } from "ethers";
import toml from "toml";
import prettier from "prettier";
import { DeploymentData, ExportConfig } from "./type";
import { getContractDataFromDeployments } from "./deployment";
import { Address } from "viem";

export const generatedContractComment = `
/**
 * This file is autogenerated by scaffold-stylus.
 * You should not edit it manually or your changes might be overwritten.
 */
import { GenericContractsDeclaration } from "../utils/scaffold-eth/contract";
`;

/**
 * Reads the contract name from Cargo.toml in the given contract folder.
 * Throws if the file or name field is missing.
 */
export function getContractNameFromCargoToml(contractFolder: string): string {
  const cargoTomlPath = path.join(contractFolder, "Cargo.toml");
  if (!fs.existsSync(cargoTomlPath)) {
    throw new Error(
      `Cargo.toml not found in contract folder: ${cargoTomlPath}`,
    );
  }
  const tomlContent = fs.readFileSync(cargoTomlPath, "utf8");
  let parsed: any;
  try {
    parsed = toml.parse(tomlContent);
  } catch (e) {
    throw new Error(`Failed to parse Cargo.toml: ${e}`);
  }
  if (!parsed.package || !parsed.package.name) {
    throw new Error(
      `Missing [package] or name field in Cargo.toml at ${cargoTomlPath}`,
    );
  }
  return parsed.package.name;
}

export function isContractHasConstructor(contractFolder: string): boolean {
  const contractPath = path.resolve(contractFolder, "src/lib.rs");
  if (!fs.existsSync(contractPath)) {
    throw new Error(`lib.rs not found in contract folder: ${contractPath}`);
  }
  const contractContent = fs.readFileSync(contractPath, "utf8");
  return contractContent.includes("#[constructor]");
}

export function getExportConfig(
  contractFolder?: string,
  contractName?: string,
  chainId?: string,
): ExportConfig {
  if (!contractFolder) {
    throw new Error("Contract folder is required");
  }

  contractName = contractName || getContractNameFromCargoToml(contractFolder);
  const deploymentDir = process.env["DEPLOYMENT_DIR"] || "deployments";

  const deploymentData = getContractDataFromDeployments(
    deploymentDir,
    contractName,
    chainId,
  );
  if (!deploymentData) {
    throw new Error(
      `âŒ Contract address for '${contractName}' not found in any chain-specific deployment files in ${deploymentDir}. Please deploy the contract first.`,
    );
  }

  return {
    contractFolder,
    contractName,
    deploymentDir,
    contractAddress: deploymentData.address as Address,
    txHash: deploymentData.txHash,
    chainId: deploymentData.chainId,
  };
}

export function isContractFolder(contractFolder: string): boolean {
  const cargoTomlPath = path.join(contractFolder, "Cargo.toml");
  const libRsPath = path.join(contractFolder, "src", "lib.rs");
  const mainRsPath = path.join(contractFolder, "src", "main.rs");
  return (
    fs.existsSync(cargoTomlPath) &&
    fs.existsSync(libRsPath) &&
    fs.existsSync(mainRsPath)
  );
}

export function generateContractAddress(): string {
  // Generate a random private key and derive the address
  const wallet = ethers.Wallet.createRandom();
  return wallet.address;
}

export function extractDeploymentInfo(output: string): DeploymentData | null {
  let result: DeploymentData | null = null;
  const lines = output.split("\n");
  for (const line of lines) {
    if (line.includes("deployed code at address:")) {
      // Extract the hex address directly
      const hexMatch = line.match(/(0x[a-fA-F0-9]{40})/);
      if (hexMatch && hexMatch[1]) {
        result = { address: hexMatch[1] as Address, txHash: "" };
      }
    }
    if (line.includes("deployment tx hash:")) {
      const txHashMatch = line.match(/(0x[a-fA-F0-9]{64})/);
      if (txHashMatch && txHashMatch[1]) {
        result = {
          address: result?.address as Address,
          txHash: txHashMatch[1],
        };
      }
    }
  }
  return result;
}

export function extractGasPriceFromOutput(output: string): string | null {
  const lines = output.split("\n");
  for (const line of lines) {
    if (line.includes("gas price:")) {
      // Remove ANSI color codes first
      // eslint-disable-next-line no-control-regex
      const cleanLine = line.replace(/\x1b\[[0-9;]*m/g, "");

      const match = cleanLine.match(/gas price:\s*"([^"]+)"/);
      if (match && match[1]) {
        return match[1];
      }
    }
  }
  return null;
}

export async function generateTsAbi(
  abiFilePath: string,
  contractName: string,
  contractAddress: string,
  txHash: string,
  chainId: string,
) {
  const TARGET_DIR = "../nextjs/contracts/";
  const TARGET_FILE = `${TARGET_DIR}deployedContracts.ts`;
  const abiTxt = fs.readFileSync(abiFilePath, "utf8");

  // Extract from 4th row to the end
  const lines = abiTxt.split("\n");
  const extractedAbi = lines.slice(3).join("\n");
  const abiJson = JSON.parse(extractedAbi);

  const newContractEntry = {
    address: contractAddress,
    txHash: txHash,
    abi: abiJson,
  };

  let deployedContractsObj: any = {};
  const fileHeader = generatedContractComment + "\n\n";

  if (fs.existsSync(TARGET_FILE)) {
    const fileContent = fs.readFileSync(TARGET_FILE, "utf8");
    // Extract the deployedContracts object using regex
    const match = fileContent.match(
      /const deployedContracts = ([\s\S]*?) as const;/,
    );
    if (match) {
      // eslint-disable-next-line no-eval
      deployedContractsObj = eval("(" + match[1] + ")");
    }
  }

  if (!deployedContractsObj[chainId]) {
    deployedContractsObj[chainId] = {};
  }
  deployedContractsObj[chainId][contractName] = newContractEntry;

  const contractsString = JSON.stringify(deployedContractsObj, null, 2);

  const output = `${fileHeader}const deployedContracts = ${contractsString} as const;\n\nexport default deployedContracts satisfies GenericContractsDeclaration;\n`;

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }

  fs.writeFileSync(
    TARGET_FILE,
    await prettier.format(output, { parser: "typescript" }),
  );

  console.log(
    `ðŸ“ Updated TypeScript contract definition file on ${TARGET_FILE}`,
  );
}

export function handleSolcError(
  error: Error,
  context: string = "ABI export",
): void {
  console.error(`\nâŒ ${context} failed!`);
  console.error("\nðŸ” Error details:", error.message);

  // Check if the error is related to solc not being found
  if (
    error.message.includes("solc") ||
    error.message.includes("solidity") ||
    error.message.includes("command not found")
  ) {
    console.error(
      "\nðŸ’¡ It appears that the Solidity compiler (solc) is not installed on your system.",
    );
    console.error("\nðŸ“š To install Solidity, please visit:");
    console.error(
      "   https://docs.soliditylang.org/en/latest/installing-solidity.html",
    );
    console.error(
      "\nðŸš€ After installing solc, you can run this command again:",
    );
    console.error("   yarn export-abi");
    console.error("\nðŸ“‹ Quick installation options:");
    console.error("   â€¢ npm: npm install --global solc");
    console.error("   â€¢ Docker: docker run ethereum/solc:stable --help");
    console.error("   â€¢ Homebrew (macOS): brew install solidity");
    console.error("   â€¢ Linux: sudo apt-get install solc");
  } else {
    console.error("\nðŸ’¡ Please check the error details above and try again.");
  }
}

/**
 * Dynamically load deployed contracts from the TypeScript file
 * This is useful when the file has been updated during runtime
 * @returns The deployed contracts object
 */
export function loadDeployedContracts(): any {
  const deployedContractsPath = "../nextjs/contracts/deployedContracts.ts";

  if (!fs.existsSync(deployedContractsPath)) {
    throw new Error("deployedContracts.ts file not found");
  }

  const fileContent = fs.readFileSync(deployedContractsPath, "utf8");
  const match = fileContent.match(
    /const deployedContracts = ([\s\S]*?) as const;/,
  );

  if (!match) {
    throw new Error("Could not parse deployedContracts.ts file");
  }

  // eslint-disable-next-line no-eval
  return eval("(" + match[1] + ")");
}

/**
 * Get contract data from deployed contracts
 * @param chainId - The chain ID
 * @param contractName - The contract name
 * @returns The contract data with address, txHash, and abi
 */
export function getContractData(chainId: string, contractName: string): any {
  const deployedContracts = loadDeployedContracts();

  if (
    !deployedContracts ||
    !deployedContracts[chainId] ||
    !deployedContracts[chainId][contractName]
  ) {
    throw new Error(
      `Contract ${contractName} not found in deployedContracts for chain ${chainId}`,
    );
  }

  const contractData = deployedContracts[chainId][contractName];
  if (!contractData.abi) {
    throw new Error(
      `ABI not found for contract ${contractName} on chain ${chainId}`,
    );
  }

  return contractData;
}

export function contractHasInitializeFunction(contractData: any): boolean {
  return contractData.abi.some((abi: any) => abi.name === "initialize");
}
